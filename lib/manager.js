// Generated by CoffeeScript 1.3.3
var Asset, AssetReference, EventEmitter, Manager, Storage, alib, mime, utils, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require('underscore');

mime = require('mime');

utils = require('./utility');

alib = require('./asset');

Storage = require('./storage');

EventEmitter = require('events').EventEmitter;

Asset = alib.Asset;

AssetReference = alib.AssetReference;

mime.default_type = null;

Manager = (function(_super) {

  __extends(Manager, _super);

  function Manager(options) {
    this.options = utils.opts(options, {
      default_store: null
    });
    this.types = {};
    this.loads = [];
    this.sorting_facility = {};
    utils.log("Asset Manager object initialized.");
  }

  Manager.prototype.register_type = function(type, exts, asset_class) {
    var _ref;
    if (!_.isString(type)) {
      throw new Error("Expecting a string for the first argument.");
    }
    if (_.isFunction(exts) && (new exts) instanceof Asset) {
      _ref = [null, exts], exts = _ref[0], asset_class = _ref[1];
    }
    if (!(_.isFunction(asset_class) && (new asset_class) instanceof Asset)) {
      asset_class = Asset;
    }
    if (_.has(this.types, type)) {
      throw new Error("Type `" + type + "` has already been registered. Call `unregister_type()` before calling this method to prevent this error.");
    }
    this.types[type] = {
      exts: [],
      asset: asset_class
    };
    this.emit("register_type", type, asset_class);
    utils.log("Asset type `" + type + "` registered.");
    return this.define_exts(type, exts);
  };

  Manager.prototype.unregister_type = function(type) {
    if (_.has(this.types, type)) {
      this.emit("unregister_type", type);
      delete this.types[type];
      return utils.log("Asset type `" + type + "` removed.");
    }
  };

  Manager.prototype.define_exts = function(t, exts, override) {
    var ext_arr, type;
    type = this._get_type(t);
    if (override) {
      type.exts = [];
    }
    ext_arr = type.exts;
    if (_.isObject(exts) && !_.isArray(exts)) {
      mime.define(exts);
      exts = _.flatten(_.values(exts));
    }
    if (_.isString(exts) && _.indexOf(ext_arr, exts) === -1) {
      ext_arr.push(exts);
    } else if (_.isArray(exts)) {
      _.each(exts, function(ext) {
        if (_.isString(ext) && _.indexOf(ext_arr, ext) === -1) {
          return ext_arr.push(ext);
        }
      });
    } else {
      return;
    }
    this.emit("define_exts", t, exts, override);
    return utils.log("Extensions `." + (type.exts.join("`, `.")) + "` now pointing to Asset type `" + t + "`.");
  };

  Manager.prototype.ext_to_type = function(ext) {
    var type;
    type = null;
    _.find(this.types, function(obj, t) {
      if (_.indexOf(obj.exts, ext) > -1) {
        return type = t;
      }
    });
    return type;
  };

  Manager.prototype.extensions = function(type) {
    return this._get_type(type).exts;
  };

  Manager.prototype.new_asset = function() {
    var args, asset, create, type;
    type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    Asset = this._get_type(type).asset;
    create = function() {
      var F;
      F = function(args) {
        return Asset.apply(this, args);
      };
      F.prototype = Asset.prototype;
      return new F(arguments);
    };
    asset = create.apply(null, args);
    asset.type = type;
    asset._manager = this;
    asset._storage = this.options.default_store;
    this.emit("new_asset", asset);
    return asset;
  };

  Manager.prototype._get_type = function(type) {
    if (!_.has(this.types, type)) {
      throw new Error("Type `" + type + "` has not been registered.");
    }
    return this.types[type];
  };

  Manager.prototype.register_load = function(name, priority, fnc) {
    var i, nl, _ref;
    if (!_.isString(name)) {
      throw new Error("Expecting a string for the first argument.");
    }
    if (_.isFunction(priority) && !fnc) {
      _ref = [priority, null], fnc = _ref[0], priority = _ref[1];
    }
    if (!_.isNumber(priority)) {
      priority = 0;
    }
    if (!_.isFunction(fnc)) {
      throw new Error("Expecting a function for the last argument.");
    }
    if (this._get_load(name, false, true)) {
      throw new Error("Load Strategy `" + name + "` has already been registered. Call `unregister_load()` before calling this method to prevent this error.");
    }
    nl = {
      name: name,
      priority: priority,
      callback: fnc
    };
    i = _.sortedIndex(this.loads, nl, function(load) {
      return load.priority;
    });
    this.loads.splice(i, 0, nl);
    this.emit("register_load", name, priority, fnc);
    return utils.log("Load Strategy `" + name + "` registered.");
  };

  Manager.prototype.unregister_load = function(name) {
    var i;
    i = this._get_load(name, true, true);
    if (i != null) {
      this.emit("unregister_load", name);
      return this.loads.splice(i, 1);
    }
  };

  Manager.prototype.load = function() {
    var args, cb, current, loads, next, run_cb, _i,
      _this = this;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
    loads = _.pluck(this.loads, "callback");
    current = -1;
    this.emit.apply(this, _.flatten(["on_load", _.toArray(arguments)]));
    run_cb = _.once(function() {
      try {
        _this.emit.apply(_this, _.flatten(["loaded", _.toArray(arguments)]));
        return cb.apply(null, arguments);
      } catch (e) {
        return utils.log("error", e.message);
      }
    });
    next = function(asset) {
      if (asset instanceof Error) {
        return run_cb(asset);
      } else if (asset instanceof Asset) {
        return run_cb(null, asset);
      } else {
        current++;
        args.push(next);
        if (!_.isFunction(loads[current])) {
          return run_cb(null, null);
        }
        try {
          return loads[current].apply(_this, args);
        } catch (e) {
          return next(e);
        }
      }
    };
    return next();
  };

  Manager.prototype.exec_load = function() {
    var args, cb, load, name, _i;
    name = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    if (!_.isFunction(cb)) {
      throw new Error("Expecting a function for the last argument.");
    }
    load = this._get_load(name);
    args.push(cb);
    return load.callback.apply(this, args);
  };

  Manager.prototype._get_load = function(name, index, silence) {
    var i, load;
    i = null;
    load = _.find(this.loads, function(load, _i) {
      if (load.name === name) {
        i = _i;
        return true;
      }
    });
    if (!(load || silence)) {
      throw new Error("Load Strategy `" + name + "` has not been registered.");
    } else if (index) {
      return i;
    } else {
      return load;
    }
  };

  Manager.prototype.register_storage = function(name, storage) {
    if (!(_.isString(name) && name)) {
      throw new Error("Expecting a string for the first argument.");
    }
    if (this.get_storage(name)) {
      throw new Error("Storage `" + name + "` has already been registered. Call `unregister_storage()` before calling this method to prevent this error.");
    }
    if (!(storage instanceof Storage)) {
      storage = new Storage();
    }
    storage.name = name;
    storage.manager = this;
    this.sorting_facility[name] = storage;
    this.emit("register_storage", name, storage);
    utils.log("Storage Engine `" + name + "` registered.");
    if (!this.options.default_store) {
      return this.use_storage(name);
    }
  };

  Manager.prototype.use_storage = function(name) {
    if (!this.get_storage(name)) {
      throw new Error("Storage `" + name + "` has not been registered.");
    }
    this.options.default_store = name;
    return utils.log("Default Storage Engine set to `" + name + "`.");
  };

  Manager.prototype.get_storage = function(name) {
    var _ref;
    if (!_.isString(name)) {
      name = this.options.default_store;
    }
    if (!name) {
      return null;
    }
    return (_ref = this.sorting_facility[name]) != null ? _ref : null;
  };

  Manager.prototype.unregister_storage = function(name) {
    if (this.get_storage(name)) {
      this.emit("unregister_storage", name);
      delete this.sorting_facility[name];
      return utils.log("Storage Engine `" + name + "` removed.");
    }
  };

  return Manager;

})(EventEmitter);

module.exports = Manager;
